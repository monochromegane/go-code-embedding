package embedding

type data struct {
	Package string
}

type templates []*template

func (ts templates) toString() string {
	var template string
	for _, t := range ts {
		template = template + t.text
	}
	return template
}

var codeTemplates = templates{
	packageTpl,
	importTpl,
	fsTpl,
	initTpl,
	embedCodeTpl,
}

type template struct {
	name string
	text string
}

var packageTpl = &template{
	name: "package",
	text: `// Code generated by go-code-embedding.
// DO NOT EDIT!
package {{ .Package }}
`}

var importTpl = &template{
	name: "import",
	text: `
import (
        "bytes"
        "embed"
        "flag"
        "fmt"
        "io"
        "io/fs"
        "os"
        "path/filepath"
        "strings"
)
`}

var fsTpl = &template{
	name: "fs",
	text: `
//go:embed *.go */**/*.go go.mod go.sum
var sourceCodeFS embed.FS
`}

var initTpl = &template{
	name: "init",
	text: `
func init() {
        var path string
        var list bool
        var restore bool
        var restorePath string

        f := flag.NewFlagSet(os.Args[0], flag.ContinueOnError)

        f.StringVar(&path, "show-code", "", "show specified source code")
        f.BoolVar(&list, "list-codes", false, "list source codes")
        f.BoolVar(&restore, "restore-codes", false, "restore source codes")
        f.StringVar(&restorePath, "restore-path", ".", "restore source codes to specified path")

        buf := &bytes.Buffer{}
        f.SetOutput(buf)

        err := f.Parse(os.Args[1:])
        if err != nil {
                // Continue if flag not found
                if strings.Contains(err.Error(), "flag provided but not defined:") {
                        return
                }
                // Continue if flag is "h" or "help"
                if err == flag.ErrHelp {
                        fmt.Fprintln(os.Stderr, buf.String())
                        return
                }
                // Exit if flag has error
                fmt.Fprintln(os.Stderr, buf.String())
                os.Exit(2)
        }

        if list {
                newEmbedCode().list()
                os.Exit(0)
        }

        if path != "" {
                err := newEmbedCode().show(path)
                if err != nil {
                        fmt.Fprintln(os.Stderr, err)
                        os.Exit(1)
                }
                os.Exit(0)
        }

        if restore {
                newEmbedCode().restore(restorePath)
                if err != nil {
                        fmt.Fprintln(os.Stderr, err)
                        os.Exit(1)
                }
                os.Exit(0)
        }
}
`}

var embedCodeTpl = &template{
	name: "embedCode",
	text: `
type embedCode struct {
        writer io.Writer
}

func newEmbedCode() *embedCode {
        return &embedCode{writer: os.Stdout}
}

func (e *embedCode) list() error {
        return fs.WalkDir(sourceCodeFS, ".", func(path string, d fs.DirEntry, err error) error {
                if path == "." || path == ".." {
                        return nil
                }
                if d.IsDir() {
                        return nil
                }
                e.write(path)
                return nil
        })
}

func (e *embedCode) show(path string) error {
        code, err := fs.ReadFile(sourceCodeFS, path)
        if err != nil {
                return err
        }
        e.write(string(code))
        return nil
}

func (e *embedCode) restore(out string) error {
        return fs.WalkDir(sourceCodeFS, ".", func(path string, d fs.DirEntry, err error) error {
                if path == "." || path == ".." {
                        return nil
                }
                if d.IsDir() {
                        return os.MkdirAll(filepath.Join(out, path), 0755)
                }

                code, err := fs.ReadFile(sourceCodeFS, path)
                if err != nil {
                        return err
                }
                return os.WriteFile(filepath.Join(out, path), code, 0644)
        })
        return nil
}

func (e *embedCode) write(s string) {
        fmt.Fprintln(e.writer, s)
}
`}
